# DankruptVRF v.0.0.1
## By:  Post Capone

### Released: 5.31.22
### License:  The MIT License

This repository is not an exact copy of the the DankruptVRF v.0.0.1 and should not be used as a source when implementing.  This repository is meant to be a guide for how to use as well as a place for others to contribute to future version releases.

The logic represented in the function here is identical to the logic of the source function (CID: QmTvPv1fzuyBmNkSNwtgUpt8qqCjxREeGWGsXVaJTXiGpT).  Some additional comments may be added to dankruptVRF.js to improve readability and developer experience.

## Alright, let's get started:

The easiest and likely most common execution of the VRF will be through a browser.  While there are other ways to use the function, this readMe will focus on the implementation of the VRF through a valid .html file, and we will discuss how to import the correct resources.

It is possible to import sources from a number of locations.  In order to strengthen the verifiability and immutability of the values, Dankrupt insists that IPFS is used as is specified and where is specified in the implementation.

If any participant implements this with a scheme which takes any sources which are specified here as IPFS sources, but instead uses some other sources, Dankrupt considers that an incorrect and invalid implementation, and does not support the claim to verifiable randomness in that implementation.

### For NFT Creators:  Dankrupt suggests that when you choose to use the DankruptVRF, you make it known in advance that the DankruptVRF will be used for the distribution of your collection.  Please make sure to include the "dankruptVRF" key in your collectionData.JSON, and set this value to the desired version of the VRF (the only version available today would be "0.0.1")

### For Non-Technical NFT Creators:  If you would like hands-on assistance in making use of the DankruptVRF, you are welcome to visit us: https://discord.gg/ApFvUW8k

### For participants who wish to use the DankruptVRF to verify for themselves the randomness and validity of a distribution:  This guide will show how to implement the VRF and run it locally.  There may also be any number of places online you can visit to check the VRF output.  This guide should be helpful in being able to verify that those implementations are correct and that the output is a valid and honest output.

First requirement:  The NFT Creator will need to create and publish the collectionData.JSON

It is recomended that this be published as soon as is possible.  If you want to publish this early, but you do not want to upload your collection to IPFS prior to mint, we recomend: https://github.com/alanshaw/ipfs-only-hash

This tool can be used to pre-calculate the IPFS CIDs of your NFT image files.  Once you have the CID values, you can assemble your metadata files and pre-calculate those as well.  It is not required that the content exist in IPFS until your participants are ready to verify the results.

You might want to check out Issue 21 of the ipfs-only-hash repo: https://github.com/alanshaw/ipfs-only-hash/issues/21
This issue will detail how to use the tool to get the correct IFPS CID which will be generated by myPinata (you will need to use --cid-version=0)


Here is the collectionData.JSON we are using for this demonstration (which is also available in the repo files):

```
{
	"title": "Classic Game GIFs",
	"series": "1",
	"artist": "poesch",
	"perMintCost": "40",
	"maxMintPerPerson": "2",
	"dankruptVRF": "0.0.1",
	"metaCids": {
		"cid1": "QmfEAYGSibSKtFHS23gDRFFcSJf7cqNuPCQxz6eFVM1hYr",
		"cid2": "Qmc9S4wX3VorKNd9fRKBWZDufrHBYiztnvNNsfjS8tdHb4",
		"cid3": "QmTH5esb8JMzZY6R5zar68qKyQwNUuDHjqiDfPqr7Jjhj2",
		"cid4": "QmVaAThvbjdqZwYHvJ8j5yni719d4PmQsmfCtCVKz7Frsj",
		"cid5": "QmSYQt2F2yXhau4VQuqBaeUHGgukgM8brXGrhmQNy2Ep6D",
		"cid6": "QmVroLyeHJDS5ZNrJPzbgQnSMPJVmig6zjS5M43y85Jj9F",
		"cid7": "QmQL8ZiYfNDNPUGa54Rwi9bGhxJ1nYEaGgFjmRRfNvg6rg",
		"cid8": "QmTiEt16EaXbvDopaHoq5Ki5ciSAxkUQbjznjyPSnVfXy9",
		"cid9": "QmchrSixxNXhFT9KK4MuBuBuW1Txuq16oY3NgiXf3YnYSA",
		"cid10": "QmXHoDmz5Tskc14TZMLEDGAYDaQ81ZeSoPzByKTmxLVvjJ",
		"cid11": "QmbzhAmw85VDefzsNW9EqHff5SU5wD2JGSNR8ZPB2xqXJy",
		"cid12": "QmSQr7gwRG48Ea3cFqnTktZN9kLgiAzANyVxGqrPJwFKU3",
		"cid13": "QmUqWontGSRyeiqCxXftXHmttDnpKi4B9AcK3NxurYvUQb"
	}
}
```

The current version of the VRF will only make use of "perMintCost", "maxMintPerPerson", and "metaCids" (along with each "cidXX" contained within this key) however, you can include any number of other key:value pairs.

Including other information here may actually provide very useful for yourself from a front end design perspective.  The data here will be available any time the DankruptVRF is being called on your collection, and so it can be used to extend more information.  For example, since we have the title, series, and artist information here, I could always throw this up in a Dankrupt website and show off your NFTs, along with the relevant information about the collection.  Super neat :)

#### It is highly recomended (but not required in the current version) that you include
> "dankruptVRF": "0.0.1",

This means that even after future versions are released, the client can always know which DankruptVRF is appropriate to use for your collection.
It frees contributors up to really think outside the box about improvements and work with minimal restrictions.
Future Proofing your collection is always a good idea!

Second Requirement:  Once the transactions for the participants have been finalized, the NFT creator will need to create and publish the transactionData.JSON
In order for the results to be considered fully verifiable, it is necessary that these transactions be in order as they are recieved on Loopring's Layer 2.  Changing the order of these transactions **WILL** change the output of DankruptVRF.

Future additions from Dankrupt are planned to include a tool which checks the transactionData.JSON against data from Loopring to verify the that transactions are a complete, valid, and correctly ordered copy of the transactions which participated in the mint.

In order to accomplish this, future versions of DankruptVRF may require some additional information in the transaction, such as a certain string to be included in the comment of the transaction.  Dankrupt plans to make this as easy and intuitive as possible, and hopefully offer automation tools to help your particpants leverage this technique.

You can, yourself, require a comment such as this in order to claim the transaction as a valid mint, if you would like.
For now, a transactionData.JSON which is not in the correct order **might** be considered a dishonest report of the transactions, so, let's just keep them in order.

Here is the transactionData.JSON we are using for the demonstration (which is also available in the repo files):

```
{
	"transaction1": {
		"ethAddress": "0x5c67732f63323dabf70ebdded102bff210d086ca",
		"value": "40"
	},
	"transaction2": {
		"ethAddress": "0x5bdb878c6dcb352699a4500cd21797950a46b7ba",
		"value": "80"
	},
	"transaction3": {
		"ethAddress": "0x08950ea47bc614cef701adaf214273dc1278ff7f",
		"value": "40"
	},
	"transaction4": {
		"ethAddress": "0xd59caad715653404eeb053cabe7a7baf8a3b683d",
		"value": "80"
	},
	"transaction5": {
		"ethAddress": "0xd59caad715653404eeb053cabe7a7baf8a3b683d",
		"value": "40"
	},
	"transaction6": {
		"ethAddress": "0x0c90ad36f195b00ff1e43d8708499004425e879d",
		"value": "40"
	},
	"transaction7": {
		"ethAddress": "0xceed93150b2557cab377c138b96c00630c524066",
		"value": "40"
	}
}
```

If you notice, we have one account which sent two transactions that made it into our list.  In the first transaction, they sent 80 LRC, which happens to equal the maxMintPerPerson claim of 2 mints with a perMintCost of 40 LRC (from collectionData.JSON above).

This is totally fine.  DankruptVRF will automatically locate multiple transactions from the same account, combine their values, and only allow that account to claim the maxMintPerPerson for the collection.

## Now on to the implementation:

EZPZ setup = use valid .html and import the necessary assets here.  In this repository, we have index.html which shows sort of the minimal requirements to get up and running.  Lines 9-13 of this file are what differ from just a typical .html boiler plate, so that is what we will focus on here:

```
09    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
10    <script src="https://cdnjs.cloudflare.com/ajax/libs/js-sha256/0.9.0/sha256.min.js"></script>
11    <script>var collectionInput = 'https://loopring.mypinata.cloud/ipfs/';</script>
12    <script>var transactionInput = 'https://loopring.mypinata.cloud/ipfs/';</script>
13    <script src="https://gateway.pinata.cloud/ipfs/QmTvPv1fzuyBmNkSNwtgUpt8qqCjxREeGWGsXVaJTXiGpT"></script>
```

> Lines 9 and 10 we are importing the two JS dependancies, jquery and the sha256 library we will be using to create our hash values

> Line 11 is where we import the CID for our collectionData.JSON
> The CID for our example collectionData.JSON is QmPX6eFamwuDNaUDdJKgE8CUS4NEknVsKgAiNgkJLTwCnL
> You can copypasta this .html, enter this CID at the end of the https path on Line 11, and use this to test DankruptVRF

> Line 12 is where we import the CID for our transactionData.JSON
> The CID for our example transactionData.JSON is Qmcq3u69NXiacJqnJ2NMW9znAMkpaS6s7Pp2XoAiF6M7A2
> You can copypasta this .html, enter this CID at the end of the https path on Line 12, and use this to test DankruptVRF

> Line 13 we are importing the DankruptVRF v.0.0.1 (CID: QmTvPv1fzuyBmNkSNwtgUpt8qqCjxREeGWGsXVaJTXiGpT)

That's actually it.  This is now a fully functioning implementation of DankruptVRF.  If you load this into vscode or a similar IDE, and open it using liveserver (or just plop it into a functioning library), you can open your browsers console (inspect element - ctrl+shift+i for most browsers) and you will see something like this:
```
0: "0x5bdb878c6dcb352699a4500cd21797950a46b7ba has won ipfs://QmTMh8mPUnPZ3cLozuz12huczWzihepofyoxioPx27ydBw/Castlevania.gif"
1: "0x5c67732f63323dabf70ebdded102bff210d086ca has won ipfs://QmdXkSBbLVziCojfFuPP8Ac3NNbBp92VpStrVnYPvCW4Tp/Pokemon.gif"
2: "0xd59caad715653404eeb053cabe7a7baf8a3b683d has won ipfs://QmVQvfo3DbH88WaCcSJH2GnmSJEzHEvwYb3TaNC2E1Bb4k/Tetrisd.gif"
3: "0xceed93150b2557cab377c138b96c00630c524066 has won ipfs://QmTrnP7GYC25G6KKfYDkyJeBQ4fsuKUBfsfoK7iEqc75zf/Megaman.gif"
4: "0x5bdb878c6dcb352699a4500cd21797950a46b7ba has won ipfs://QmYZ5XGPoLpH4WWAheU5MebEmLHgJ96jP6bPoCsi45Up9y"
5: "0x08950ea47bc614cef701adaf214273dc1278ff7f has won ipfs://QmVd1VDPRMMJi7pDmPHx4tN1DjEDMqUQ5wwrSMahptQrUh/0475.gif"
6: "0xd59caad715653404eeb053cabe7a7baf8a3b683d has won ipfs://QmVLjncN5X8SgkftgJqNuRcKEjaMW8694SsUuruTHQ9C4c"
7: "0x0c90ad36f195b00ff1e43d8708499004425e879d has won ipfs://QmXsKbjZ11WFwu6RLYpi1ZangJKupsaAN41am1kMX5XVC3"
```

Ta-Da!  We now see precisely who won which NFT in each round.  Notice that we actually used metaData CIDs from multiple collections here.  This means you can use this VRF for more than just mints!  If you wanted to raffle off a set of NFTs from your own personal collection, that would be pretty easy to accomplish.

There's a lot more coming for this tool.  We mentioned earlier being able to take information from the collectionData.JSON and use it to extend the front end as a UI tool for website implementations.  Dankrupt has plans to produce a DankruptUI Helper to do just that, actually!


## Note From the Author, Post Capone

My vision for Dankrupt is to offer really dope tools to improve the Loopring Ecosystem.  I'm a big believer that users make the network.  Hopefully, this is the first of many contributions.  I encourage anyone who has any criticisms, thoughts, questions, or decent jokes to share to reach out :) - PostCapone.loopring.eth
